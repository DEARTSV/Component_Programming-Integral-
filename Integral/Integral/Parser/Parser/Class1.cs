//Парсер. Функция будет составляться методом обратной польской записи.
//Описание метода в \Integral\Integral\Readme

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using System.ComponentModel;

namespace ParserMathExpressions
{
    //Структура для операций типа "действие" и их приоритетов
    struct Operation
    {
        //Операция
        private string func;
        //Её приоритет
        private int rang;

        //Базовый метод структуры. Присваиваем свойствам значения
        public Operation(string func, int range)
        {
            this.func = func;
            this.rang = range;
        }

        //Работа с свойством func
        public string Expression
        {
            //Когда выполняется чтение свойства func, просто возвращаем его
            get { return func; }
            //Когда свойству присваивается новое значение, просто присваеваем это значение
            set { func = value; }
        }

        //Работа с свойством rang
        public int Rang
        {
            //Когда выполняется чтение свойства
            get { return rang; }
            //Когда свойству присваивается новое значение
            set { rang = value; }
        }
    }


    public class Parser : Component
    {
        //Метод Parse будет принимать на вход строку и выводить список строк - операций (как будут представлены операции - в Readme)
        public List<string> Parse(string expression)
        {
            //Список, в который по порядку будут записываться операции (его вид - в Readme. Числа также будут являться операциями)
            List<string> postfixExpression = new List<string>();
            //Заводим стек (зачем он нужен - в Readme)
            Stack<Operation> stack = new Stack<Operation>();
            //Переводим строку в нижний регистр (заглавные буквы заменяем строчными)
            expression = expression.ToLower();
            //Приоритет последней встреченной операции типа "действие"
            int degree = 0;
            //Индикатор, показывающий, была ли предыдущая операция числом (переменную также будем считать числом)
            bool wasNumber = false;

            //Для всех символов входной строки
            for (int count = 0; count < expression.Length; count++)
            {
                //Пытаемся парсить
                try
                {
                    //Если символ - цифра, точка или запятая
                    if ((expression[count] >= '0' && expression[count] <= '9') || expression[count] == '.' || expression[count] == ',')
                    {
                        //Если предыдущая операция была числом, значит, между двумя числами не было действия. Выводим ошибку
                        if (wasNumber) 
                            throw new Exception("Ошибка. Проверьте корректность введенных операторов");
                        //Добавляем число к списку операций. Для парсинга числа используется функция ParseNumber
                        //ref count - ссылка. Используется для того, чтобы функция ParseNumber также могла инкрементировать count, и после парсинга числа мы могли парсить дальше
                        postfixExpression.Add(ParseNumber(expression, ref count));
                        //Индикатор, что операция была числом
                        wasNumber = true;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - переменная
                    if (expression[count] == 'x')
                    {
                        //Если предыдущая операция была числом, значит, между числом и переменной не было действия. Выводим ошибку
                        if (wasNumber)
                            throw new Exception("Ошибка. Проверьте корректность введенных операторов");
                        //Добавляем переменную к списку операций
                        postfixExpression.Add("x");
                        //Индикатор, что операция была числом (т.к. переменную тоже считаем числом)
                        wasNumber = true;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - буква, не являющаяся переменной...
                    if (expression[count] >= 'a' && expression[count] <= 'z' && expression[count] != 'x')
                    {
                        //...значит, это - подфункция. Парсим её
                        string func = ParseFunction(expression, ref count);
                        //Т.к. это - подфункция, то её приоритет - максимальный(5).
                        //Добавляем к спику операций верхниие операции из стека с максимальным приоритетом (т.е. другие подфункции), если имеем выражение вида "('подфункции'('подфонкция'))"
                        PopStack(postfixExpression, stack, 5);
                        //Добавляем распарсенную подфункцию к стеку
                        stack.Push(new Operation(func, 5));
                        //Устанавливаем максимальный текущий приоритет
                        degree = 5;
                        //Подфункция - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - сложение/вычитание
                    if (expression[count] == '+' || expression[count] == '-')
                    {
                        //Если текущий приоритет меньше двух (т.е. минимальный) и предыдущая операция не была числом, значит, случай открывающей скобки: имеем "(-'какое-то выражение')"
                        if (degree < 2 && !wasNumber)
                        {
                            //Добавляем к спику операций верхниие операции из стека с максимальным приоритетом (подфункции)
                            PopStack(postfixExpression, stack, 5);
                            //Добавляем подфункцию negative(x) к стеку
                            stack.Push(new Operation("neg", 5));
                            //Устанавливаем максимальный текущий приоритет (т.к. подфункция)
                            degree = 5;
                            //Подфункция - операция действия, а не операция "число"
                            wasNumber = false;
                            //Переходим к следующему символу
                            continue;
                        }
                        //Если не negative(x), то будет осуществляться сложение/вычитание
                        //Если текущий приоритет >=2, имеем выражение вида "('выражение'+'выражение')" или "('выражение'-'выражение')". Нужно добавить первое выражение к списку операций
                        //Для этого нужно вытащить из стека операции, чей приоритет >=2 (т.к. приоритет 1 - это скобка)
                        if (degree >= 2)
                            //Добавляем к спику операций верхниие операции из стека с приоритетом >=2 (подфункции, степень, умножение/деление, сложение/вычитание)
                            PopStack(postfixExpression, stack, 2);
                        //Иначе имеем выражение вида "('число'+'какое-то выражение')" или "('число'-'какое-то выражение')"
                        //Добавляем к стеку операцию сложения/вычитания
                        stack.Push(new Operation(expression[count].ToString(), 2));
                        //Устанавливаем текущий приоритет, соответствующий сложению/вычитанию
                        degree = 2;
                        //Сложение/вычитание - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue; 
                    }
                    //Если символ - умножение/деление
                    if (expression[count] == '*' || expression[count] == '/')
                    {
                        //Если текущий приоритет >=3, имеем выражение вида "('выражение'*'выражение')" или "('выражение'/'выражение')". Нужно добавить первое выражение к списку операций
                        //Для этого нужно вытащить из стека операции, чей приоритет >=3 (т.к. приоритет 1 - это скобка)
                        if (degree >= 3)
                            //Добавляем к спику операций верхниие операции из стека с приоритетом >=3 (подфункции, степень, умножение/деление) 
                            PopStack(postfixExpression, stack, 3);
                        //Иначе имеем выражение вида "('число'+'какое-то выражение')" или "('число'-'какое-то выражение')"
                        //Добавляем к стеку операцию умножения/деления
                        stack.Push(new Operation(expression[count].ToString(), 3));
                        //Устанавливаем текущий приоритет, соответствующий умножению/делению
                        degree = 3;
                        //Умножение/деление - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - возведение в степень
                    if (expression[count] == '^')
                    {
                        //Если текущий приоритет >=4, имеем выражение вида "('выражение'^'выражение')". Нужно добавить первое выражение к списку операций
                        //Для этого нужно вытащить из стека операции, чей приоритет >=4 (т.к. приоритет 1 - это скобка)
                        if (degree >= 4)
                            //Добавляем к спику операций верхниие операции из стека с приоритетом >=4 (подфункции, степень) 
                            PopStack(postfixExpression, stack, 4);
                        //Добавляем к стеку операцию возведения в степень
                        stack.Push(new Operation(expression[count].ToString(), 4));
                        //Устанавливаем текущий приоритет, соответствующий возведению в степень
                        degree = 4;
                        //Возведение в степень - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - закрывающая скобка
                    if (expression[count] == '(')
                    {
                        //Добавляем её к стеку
                        stack.Push(new Operation(expression[count].ToString(), 1));
                        //Устанавливаем текущий приоритет, соответствующий скобке
                        degree = 1;
                        //Скобка - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Если символ - закрывающая скобка
                    if (expression[count] == ')')
                    {
                        //Если в стэке последний элемент - открывающая скобка, просто удаляем её
                        PopStack(postfixExpression, stack, 1);
                        //Если в стэке ещё есть элементы
                        if (stack.Count != 0) 
                            //текущий приоритет будет утсанавливаться последним действием в стеке
                            degree = stack.Peek().Rang;
                        //Иначе - устанавливаем текущий приоритет на начальный, т.е. 0
                        else
                            degree = 0;
                        //К стэку закрывающую скобку добавлять не будем
                        //Скобка - операция действия, а не операция "число"
                        wasNumber = false;
                        //Переходим к следующему символу
                        continue;
                    }
                    //Пробелы просто пропускаем
                    if (expression[count] == ' ')
                    {
                        //Переходим к следующему символу
                        continue;
                    }

                    //Если парсинг символа по описанным случаям не удался. Выведем ошибку, показав этот символ
                    throw new Exception("Найден недопустимый символ " + expression[count]);

                }
                //Исключение в случае, если парсинг символа по описанным случаям не удался
                catch (Exception exp)
                {
                    throw exp;
                }
            }

            //Если вся входная строка разобрана, а в стеке ещё остаются знаки операций, извлекаем их из стека и записываем в список операций
            PopStack(postfixExpression, stack, 0);

            //Возвращаем список операций
            return postfixExpression;
        }

        //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Далее - используемые парсером функции

        //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //Парсим число (таким образом можем парсить любое число вида double)
        private string ParseNumber(string expression, ref int count)
        {
            //Пустая строка, в которую будем записывать наше число
            string result = "";
            //Индикаторы, показывающие, сколько точек в числе мы нашли
            bool oneDot = false, twoDot = false;
            //Пока индекс не вышел за пределы конца входной строки или пока не нашли символ, не являющийся цифрой/точкой 
            while (count < expression.Length && ( (expression[count] >= '0' && expression[count] <= '9') || expression[count] == '.' || expression[count] == ','))
            {
                //Если нашли точку(или, что то же самое, запятую)
                if (expression[count] == '.' || expression[count] == ',')
                {
                    //Если до этого точка уже была найдена...
                    if (oneDot) 
                    {
                        //...то это уже вторая точка в числе. Индикатор, что нашли вторую точку
                        twoDot = true;
                        continue;
                    }
                    //Индикатор, что нашли точку
                    oneDot = true;
                }
                //Если символ - не запятая
                if (expression[count] != ',')
                    //Добавляем соответствующий символ к искомому числу
                    result += expression[count];
                //Если запятая, заменяем её точкой
                else
                    result += '.';
                count++;
            }
            //Если в числе содержится более одной точки, выводим ошибку
            if (twoDot)
                throw new Exception("Cинтаксическая ошибка. Найдено 2 точки в записи числа");
            //Возвращаеся на один символ назад (т.к. сейчас находимся за пределами числа)
            count--;
            //Возвращаем найденное число
            return result;
        }

        //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //Парсим подфункцию
        private string ParseFunction(string expression, ref int count)
        {
            //Индекс первого символа данной подфункции в исходной строке (т.е. в исходной функции)
            int start = count;
            //Пока индекс не вышел за пределы конца входной строки или пока не нашли символ, не являющийся буквой
            while (count < expression.Length && expression[count] >= 'a' && expression[count] <= 'z')
            {
                //Продолжаем движение по строке
                count++;
            }
            //Получаем подфункцию
            string func = expression.Substring(start, count - start);
            //Возвращаеся на один символ назад (т.к. сейчас находимся за пределами подфункциифункции)
            count--;
            //Если приортитет подфункции не найден, выводим ошибку
            if (GetDegree(func) == 0) 
                throw new Exception("Не найдена функция " + func + ". Проверьте синтаксис");
            //Возвращаем найденную подфункцию
            return func;
        }

        //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //Определяем приоритет операции "действие". Если операция не найдена, возвращаем 0
        private int GetDegree(string expression)
        {
            if (expression == "sin" || expression == "cos" || expression == "log" ||
                expression == "arccos" || expression == "arcsin" || expression == "exp" ||
                expression == "tg" || expression == "ctg" || expression == "arctg" ||
                expression == "arcctg" || expression == "neg") { return 5; }
            if (expression == "^") { return 4; }
            if (expression == "*" || expression == "/") { return 3; }
            if (expression == "+" || expression == "-") { return 2; }
            if (expression == "(" || expression == ")") { return 1; }
            return 0;
        }

        //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //Добавление к списку операций верхних операций из стека, пока не встретим операцию с приоритетом ниже приоритета заданной операции
        private void PopStack(List<string> expressions, Stack<Operation> stack, int degree)
        {
            //Пока в стэке есть элементы и приоритет верхнего (последнего добавленного) элемента стека больше заданного или равен ему
            while (stack.Count() > 0 && stack.Peek().Rang >= degree)
            {
                //Если заданный приоритет - минимальный (т.е. закрывающая скобка)
                if (degree == 1)
                {
                    //... и если приоритет верхнего элемента также минимальный (т.е. открывающая скобка), просто удаляем её.
                    if (stack.Peek().Rang == 1) { stack.Pop(); break; }
                }
                //Добавляем операцию к списку операций и удаляем её из стека
                expressions.Add(stack.Pop().Expression);
            }
        }
    }
}